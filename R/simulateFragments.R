#' @title simulate scATAC-seq metadata 
#'
#' @description \code{simulateMetaData} Simulated single cell ATAC-seq metadata, created to matched simulated fragment data
#' @param simulatedFragmentData A GenomicRanges object from simulateFragments
#' @param sampleNumber 1
#'
#' @return A data.frame of simulated cellular metadata
#'
#' @export

simulateMetaData <- function(simulatedFragmentData, sampleNumber = 1){

    subMeta <- as.data.frame(GenomicRanges::mcols(simulatedFragmentData))
    subMeta <- dplyr::distinct(dplyr::select(subMeta, !c(inPeak,PeakID)))
    allCells <- unique(subMeta$CellID)

    if(sampleNumber > 1){
        averageSampleRatio = length(allCells)/sampleNumber
        cellNumbers = rpois(n = sampleNumber, lambda = ceiling(averageSampleRatio))
        normCellNumbers = round(cellNumbers/sum(cellNumbers)*length(allCells))
        while(sum(normCellNumbers) != length(allCells)){
            cellNumbers = rpois(n = sampleNumber, lambda = ceiling(averageSampleRatio))
            normCellNumbers = round(cellNumbers/sum(cellNumbers)*length(allCells))
        }

        sampleNames = unlist(lapply(1:sampleNumber, function(x){ paste(sample(LETTERS, 18, replace= TRUE), collapse = '')}))
        cellMatch <- unlist(lapply(seq_along(sampleNames), function(XX) rep(sampleNames[XX],normCellNumbers[XX])))
        subMeta$Sample = cellMatch
        
    }else{

        subMeta$Sample <- paste(sample(LETTERS, 20, replace= TRUE), collapse = '')
        
    }

    rownames(subMeta) <- subMeta$CellID
    
    return(subMeta)

}


#' @title simulate scATAC-seq fragments
#'
#' @description \code{simulateFragments} Simulated single cell ATAC-seq fragments from a single population of cells.
#' @param nCells Number of cells to simulate (i.e. size of the cell population) Default is 500
#' @param meanFragsPerCell Mean number of fragments to be assigned per cell. A distribution will be build around this. Default is 5000
#' @param fragThreshold Minimum number of fragments per cell. This mimic QC thresholding for poor quality cells. 
#'               Cells with fewer than this number of fragments will be regenerated. Default is 1000. 
#' @param allLocationsGR A GenomicRanges object, generated by getSimulatedPeakSet. It must include all tiles across the genome, including both open and closed regions.
#' @param peakCenters The number of centers to a given peak within the peak windows. This is used to assign fragments to peaks. Default is 1.
#' @param FRIP The fraction of reads in peaks. Default is 0.9
#' @param meanLengths A vector of mean fragments lengths. Fragments lengths from scATAC-seq usually involve a diminishing period distribution, with
#'                             an initial distribution around 75 bp, and small number of peaks distributed around 200 bp, and further. For default, we do c(75,200)
#' @param lengthProbability A vector that adds up to 1 and is the same length as meanLengths. 
#'              This vector will describe the relative probability of a fragment belonging to a distribution around 
#'
#' @return A GenomicRanges object of all fragments, including settings used to generate them and Cell barcodes. 
#'
#' @export

simulateFragments <- function(nCells = 500, meanFragsPerCell = 5000, fragThreshold = 1000, 
                                allLocationsGR = getSimulatedPeakSet(), peakCenters = 1,
                                FRIP = 0.9, meanLengths = c(75, 200), lengthProbability = c(0.9, 0.1)){


    if(length(meanLengths) != length(lengthProbability)){
        stop('meanLengths and lengthProbability must be of equal length.')
    }
    if(FRIP <= 0 | FRIP > 1){
        stop('FRIP score must be greater than zero and less then or equal to 1.')
    }

    if(!is(allLocationsGR, 'GenomicRanges')){
        stop('allLocationsGR must be a GRanges object with peak locations, and non-peak background locations, as generated by getSimulatedPeakSet()')
    }
    allLocations = as.data.frame(allLocationsGR)
    peakNumber = sum(allLocations$isPeak)
    largePeakWindow = allLocations$width[1]

    #########################################################################
    ## Generate distribution of fragments per cell. 
    #########################################################################

    fragNumber = rpois(n = nCells, lambda = meanFragsPerCell)
    while(any(fragNumber < fragThreshold)){
        fragNumber[fragNumber < fragThreshold] = rpois(n = sum(fragNumber < fragThreshold), lambda = meanFragsPerCell)
    }

    #########################################################################
    ## Generate fragment number and widths for each simulated cell.
    #########################################################################
    
    ## Iterate over each cell, and generate the corresponding number of fragments with 
    ## the fragment length distribution matching the expectations. 

    ## Generate unique CellIDs
    allCellNames <- unlist(lapply(1:nCells, function(x){ paste(sample(LETTERS, 20 , replace= TRUE), collapse = '')}))
    peakWeight <- runif(n = peakNumber, min = 1, max = 8)

    message('Generating fragment lengths across theoretical cells.')

    fragList <- pbapply::pblapply(cl = NULL, X = seq_along(fragNumber), function(XX){

        # If things don't divide exactly, there will be one less fragment than technically generated,
        # which is within tolerances. 
        allLengths <- unlist(lapply(seq_along(meanLengths), function(YY){

            rpois(n = round(fragNumber[[XX]]*lengthProbability[[YY]]), lambda = meanLengths[[YY]])

        }))
        fragNum_tmp = length(allLengths)
        ## Classify the first portion as in peak, according to FRIP score, and the rest outside of the peak.
        InPeak = c(1:fragNum_tmp) <= rpois(1,FRIP*fragNum_tmp)
        ## Classify all the in-peak fragments to a given largePeakWindow
        PeakWindow <- sample(1:peakNumber, size = sum(InPeak), prob = peakWeight, replace = TRUE)

        peakID <- NA
        peakID[InPeak] <- PeakWindow

        data.frame(width = sample(allLengths, size = length(allLengths)), 
                 CellID = rep(allCellNames[XX], length(allLengths)),
                inPeak = InPeak, PeakID = peakID)

    })

    fragDF <- do.call('rbind', fragList)
    #Now let's see how many fragments fell within peaks across samples
    subFragNumber <- unlist(lapply(fragList, function(x) sum(x$inPeak)))
    #What are the peak intensities?
    peakIntensities_tmp <- as.data.frame(table(fragDF$PeakID))
    peakIntensities <- peakIntensities_tmp$Freq
    names(peakIntensities) <- peakIntensities_tmp$Var1

    #########################################################################
    ## Generate the center of each peak, and the starting position for fragments within a peak
    #########################################################################

    ##Let's identify the peakNumber that each in-peak fragment will fall into.
    peakStarts <- do.call('rbind',
        pbapply::pblapply(cl = NULL,
                  X = seq_along(peakIntensities), function(XX) {

            if(peakIntensities[XX] != 0){
                data.frame(PeakID = rep(as.numeric(names(peakIntensities)[XX]), peakIntensities[XX]))
            }else{
                NULL
            }

            })
        )


    ## This peak center should also have some noise so that it generates a sharp peak, or multiple potential peaks. 
    ## randomly generate the types of peak centers. 
    message('Generating peak centers')
    ## for each peak, randomly choose a number of peak centers (peakCenters) at positions that are between 25% and 75% of the larger peak window. 
    ## The number of centers should be weighted by the peakIntensity - that is, peaks with more centers should have more fragments. 

    if(peakCenters != 1){

        numberOfCenters = rpois(n = length(peakIntensities), lambda = peakCenters)
        numberOfCenters[numberOfCenters == 0] = 1
        ## Now that we have a good distribution, let's sample from it, according to a weighted probability, where peaks with more fragments are more likely to have more centers. 
        lambda_choices = pbapply::pblapply(cl = NULL, X = seq_along(peakIntensities), function(XX)
                        c(peakIntensities[XX], sample(c(floor(largePeakWindow*0.25):ceiling(largePeakWindow*0.75)), size = numberOfCenters[XX]))
                    ) 
        ## Generate start positions according to multiple peakcenters
        message('Generating fragment start positions & peakIDs')
        allStarts <- unlist(pbapply::pblapply(cl = NULL, X = lambda_choices, simulateFragmentStarts))

    }else{
        #Add a small amount of noise to the midpoint. 
        midPoints = largePeakWindow/2 + sample(x = c(-1,1), size = sum(fragDF$inPeak), replace = 5)*rpois(n = sum(fragDF$inPeak), lambda = 5)
        allStarts = midPoints - round(fragDF$width[fragDF$inPeak]/2)
    }

    peakStarts$FragStarts = allStarts 
    #########################################################################
    ## Merge the fragment information together, including fragment width, cell ID, peak ID, relative start, and bin ID. 
    #########################################################################

    # Now we need to merge the peakStart data frame (PeakID, Start positions, CellID) with the fragDF (fragment width, CellID, inPeak)
    # Because a given CellID can have multiple fragments fall within a peak (lambda2), we can't merge by CellID. 
    # Instead, we can simply arrange both peakStart and subFrags by CellID and then cbinds. Since both peakStart and subFrags have the same fragment number per cell, this will align,
    # and the peakIDs will be preserved. 
    subFrags <- dplyr::arrange(fragDF[fragDF$inPeak, ], PeakID)
    peakStarts <- dplyr::arrange(peakStarts, PeakID)
    #all(subFrags$PeakID == peakStarts$PeakID) All True
    subFrags$FragStarts = peakStarts$FragStarts
    
    ## Now we merge these fragments with peak locations to get their real locations. 
    
    peakFrags = dplyr::left_join(subFrags, dplyr::select(allLocations[!is.na(allLocations$PeakID),], !width),  by = 'PeakID')
    peakFrags <- dplyr::mutate(peakFrags, end = start + FragStarts + width, start = start + FragStarts)
    peakFrags <- dplyr::select(peakFrags, seqnames, start, end, CellID, PeakID, inPeak)

    #########################################################################
    ## Generate background fragments across background positions
    #########################################################################

    #### Now we need to place the non-peak fragments randomly across the genome. 
    #### let's get a complete list of all the possible locations by generating a non-peak GRanges and reducing it. 
    if(FRIP < 1){

        message('Placing background fragments into the genome')
        backgroundDF <- dplyr::select(allLocations[is.na(allLocations$PeakID),], ! width)
        backgroundDF$backBin <- 1:dim(backgroundDF)[1]
        backFrags <- fragDF[!fragDF$inPeak,c(1:3)]
        ## Randomly select a position between 1 and the maximum peak window area. This will be the middle of the background tile. 
        backFrags$FragMid <- sample(1:largePeakWindow-1, size = sum(is.na(fragDF$PeakID)), replace = TRUE) 
        ## Sample with replacement, so that a background fragment could theoretically fall within the same background region. 
        backFrags$backBin <- sample(1:dim(backgroundDF)[1], size = sum(is.na(fragDF$PeakID)), replace = TRUE)

        backFrags <- dplyr::left_join(backFrags, backgroundDF, by = 'backBin')
        backFrags <- dplyr::mutate(backFrags, end = start + FragMid + ceiling(width/2), start = start + FragMid - floor(width/2))
        backFrags <- dplyr::select(backFrags, seqnames, start, end, CellID, PeakID, inPeak)


        #Combine background and foreground into one GRangesList
        allFrags <- GenomicRanges::makeGRangesFromDataFrame(rbind(peakFrags, backFrags), keep.extra.columns= TRUE)


    }else{
        allFrags <- GenomicRanges::makeGRangesFromDataFrame(peakFrags, keep.extra.columns= TRUE)
    }

    #Add Genome info and trim
    suppressWarnings(GenomicRanges::seqinfo(allFrags) <- GenomicRanges::seqinfo(allLocationsGR))
    allFrags <- GenomicRanges::trim(allFrags)

    allFrags$nCells = nCells
    allFrags$meanFragsPerCell = meanFragsPerCell
    allFrags$fragThreshold = fragThreshold
    allFrags$peakNumber = peakNumber
    allFrags$peakCenters = peakCenters
    allFrags$largePeakWindow = largePeakWindow
    allFrags$FRIP = FRIP
    allFrags$meanLengths = paste(meanLengths, collapse =', ')
    allFrags$lengthProbability= paste(lengthProbability, collapse =', ')

    return(allFrags)
}
                                   
                                   
#'
#' @noRd

simulateFragmentStarts <- function(LambdaVector){

    centers_tmp =  LambdaVector[-1]
    #Generate weights for each center, so that fragments are not equally distributed across centers.
    if(length(centers_tmp) > 1){
        
        centWeights <- runif(n = length(centers_tmp), min = 0, max = 1)
        #Randomly select centers by the probability
        centerList <- sample(centers_tmp, size = LambdaVector[1], 
                            prob = centWeights/sum(centWeights), replace = TRUE)

        iterList = as.list(table(centerList))

        #Then do poisson sampling by the weight number of fragments for each center. 
        newStarts <- unlist(lapply(seq_along(iterList), function(x){

                rpois(iterList[[x]], lambda = as.numeric(names(iterList))[x])

        }))
    }else{

        newStarts = rpois(n = LambdaVector[1], lambda = LambdaVector[-1])

    }

    return(newStarts)
}

#' @title simulate open and closed regions across the genome
#'
#' @description \code{getSimulatedPeakSet} Simulate 
#' @param peakNumber Number of open tiles. Default is 200,000
#' @param peakSize Size of a given 'peak' or 'tile' in basepairs. Default is 500 bp. 
#' @param peakPeriodicity Open regions tend to cluster. This metric measures the periodicity of that clusters in terms of number of tiles. Default is 10 tiles.
#'              Resulting probability will be generated using a sin function, and all negative values will be set to zero, 
#'              so only one cluster of open regions will occur within a given period.
#' @param Genome A BSgenome file. Default is BSgenome.Hsapiens.UCSC.hg38,
#' @param allLocations A boolean, which determines whether or not to return all potential tiles (with open regions flagged), or just open regions. 
#'
#' @return A GenomicRanges object of regions
#'
#' @export
                                   
getSimulatedPeakSet <- function(peakNumber = 200000, peakSize = 500, 
                                peakPeriodicity = 10, Genome = BSgenome.Hsapiens.UCSC.hg38, allLocations = TRUE){

    #########################################################################
    ## Generate peak locations and background locations across the genome
    #########################################################################

    ### Now let's determine where our peaks are.
    ChromLengths = GenomeInfoDb::seqlengths(Genome)
    ChromLengths <- ChromLengths[!grepl('_', names(ChromLengths))]
     
    #Determine the number of open tiles per 
    ChromPeaks <- ceiling(ChromLengths/sum(ChromLengths)*peakNumber)
    while(sum(ChromPeaks) > peakNumber){
    
        diff <- sum(ChromPeaks) - peakNumber
        #Remove one open region from each chromosome
        for(i in which(ChromLengths  %in% sample(ChromLengths, size = diff, prob = ChromLengths, replace = TRUE))){
            
            ChromPeaks[i] = ChromPeaks[i] - 1
        }
        
    }
    
    ### Generate all possible bins, and mark peak bins at evenly spaced intervals. 
    allBins = sum(ChromLengths)/peakSize

    if(allBins <= peakNumber){
        stop('peakNumber is greater than or equal to the total number of larger open regions possible. Please change peakNumber, peakSize, or both.')
    }
    
    
    ## Generate a peak probability for every tile, based on a zero-threshold sin distribution with a period of peakPeriodicity (which is the number of tiles for the period)
    
    startBin = 500
    message('Placing open tiles across genome.')
    #This arrangement may slightly depass the ends of the chromosome when it comes to bins and trimming may be necessary before export.
    allTiles = do.call('rbind',pbapply::pblapply(cl = NULL, X = seq_along(ChromLengths), function(XX){

        #Start each chromosome at 1/2* peakSize, so that the positions are the center of each bin.
        posList <- seq(startBin,ChromLengths[[XX]], peakSize)
        
        #Generate a sinusoidal probability for all peaks, and threshold it at zero.
        peakProb <- sin((1:length(posList))*2*pi/peakPeriodicity)
        peakProb[peakProb < 0] = 0
        #Now select which bins will be open. 
        isPeak = sample(1:length(posList), size = ChromPeaks[XX], prob = peakProb)
        
        ## check whether that bin is the index of a true peak, or in-between noise.
        data.frame(chr = rep(names(ChromLengths)[[XX]], length(posList)),
                    start = posList, end = posList + (startBin -1), mid = posList+startBin/2,
                    isPeak = c(1:length(posList)) %in% isPeak)

    }))
    allTiles$PeakID = NA
    allTiles$PeakID[allTiles$isPeak] = c(1:peakNumber)
    locationGR <- GenomicRanges::makeGRangesFromDataFrame(allTiles, keep.extra.columns = TRUE)
    suppressWarnings(GenomicRanges::seqinfo(locationGR) <- GenomicRanges::seqinfo(Genome))
    
    if(!allLocations){
        locationGR <- plyranges::filter(locationGR, isPeak)
    }
    
    return(locationGR)
}
