#' @title \code{getRegulation}
#'
#' @description \code{getRegulation} takes GeneMotif correlations, TileGene correlations, and motif locations. 
#'
#'
#' @param GeneMotifLinks A data.frame of GeneMotifLinks, generated by getGeneMotifLinks
#' @param TileGeneLinks A data.frame of TileGeneLinks, generated by getTileGeneLinks.
#' @param motifList A GRanges list for all motif locations. 
#' @return fullDF A data.frame with correlations and pvalues linking Tile,Genes, and Motifs.
#'
#'
#' @export
getRegulation <- function(GeneMotifLinks,
                          TileGeneLinks,
                          motifList) {

    if(!all(unique(GeneMotifLinks$Motifs) %in% names(motifList))){
        stop('Motif names for motifList and GeneMotifLinks do not match.')
    }   

    subList <- motifList[names(motifList) %in% unique(GeneMotifLinks$Motifs)]
    #Filter GeneMotifLinks by motif presence, and annotate each tile with motifs within it.
    #Then full join the data.frames by Gene, and motif presence. 

    ## Identify motifs that overlap with significantly correlated tiles.
    allOverlap <- do.call('rbind', lapply(seq_along(subList), function(x){
        subOverlaps <- findOverlaps(StringsToGRanges(TileGeneLinks$Tiles),subList[[x]])
        data.frame(Index = queryHits(subOverlaps),
                    Motif = rep(names(subList)[x], length(queryHits(subOverlaps)))) 
    }))

    sumDF$Tiles <- TileGeneLinks$Tiles[sumDF$Index]

    TGLinks <- dplyr::full_join(TileGeneLinks, sumDF, by = 'Tiles')
    colnames(TGLinks)[grep('Tiles|Genes|Motifs', colnames(TGLinks), value = T, invert = T)] <- 
        paste('TG_', grep('Tiles|Genes|Motifs', colnames(TGLinks), value = T, invert = T))
    colnames(GeneMotifLinks)[grep('Tiles|Genes|Motifs', colnames(GeneMotifLinks), value = T, invert = T)] <- 
        paste('GM_', grep('Tiles|Genes|Motifs', colnames(GeneMotifLinks),  value = T, invert = T))
    fullDF <- dplyr::left_join(TGLinks, GeneMotifLinks, by = ('Genes' = 'Genes', 'Motifs'= 'Motifs'))

    return(fullDF)

}


